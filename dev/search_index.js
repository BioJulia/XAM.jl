var documenterSearchIndex = {"docs":
[{"location":"man/sam/","page":"SAM","title":"SAM","text":"CurrentModule = XAM\nDocTestSetup = quote\n    using XAM\nend","category":"page"},{"location":"man/sam/#SAM-files","page":"SAM","title":"SAM files","text":"","category":"section"},{"location":"man/sam/#The-SAM.Record","page":"SAM","title":"The SAM.Record","text":"","category":"section"},{"location":"man/sam/","page":"SAM","title":"SAM","text":"The XAM package supports the following accessors for SAM.Record types.","category":"page"},{"location":"man/sam/","page":"SAM","title":"SAM","text":"SAM.Record","category":"page"},{"location":"man/sam/#XAM.SAM.Record","page":"SAM","title":"XAM.SAM.Record","text":"SAM.Record()\n\nCreate an unfilled SAM record.\n\n\n\n\n\nSAM.Record(data::Vector{UInt8})\n\nCreate a SAM record from data. This function verifies the format and indexes fields for accessors. Note that the ownership of data is transferred to a new record object.\n\n\n\n\n\nSAM.Record(str::AbstractString)\n\nCreate a SAM record from str. This function verifies the format and indexes fields for accessors.\n\n\n\n\n\n","category":"type"},{"location":"man/sam/#SAM.Reader-and-SAM.Writer","page":"SAM","title":"SAM.Reader and SAM.Writer","text":"","category":"section"},{"location":"man/sam/#Reference:","page":"SAM","title":"Reference:","text":"","category":"section"},{"location":"man/sam/","page":"SAM","title":"SAM","text":"SAM.Reader\nSAM.Writer","category":"page"},{"location":"man/sam/#XAM.SAM.Reader","page":"SAM","title":"XAM.SAM.Reader","text":"SAM.Reader(input::IO)\n\nCreate a data reader of the SAM file format.\n\nArguments\n\ninput: data source\n\n\n\n\n\n","category":"type"},{"location":"man/bam/","page":"BAM","title":"BAM","text":"CurrentModule = XAM\nDocTestSetup = quote\n    using XAM\nend","category":"page"},{"location":"man/bam/#BAM-files","page":"BAM","title":"BAM files","text":"","category":"section"},{"location":"man/bam/#The-BAM.Record","page":"BAM","title":"The BAM.Record","text":"","category":"section"},{"location":"man/bam/","page":"BAM","title":"BAM","text":"The XAM package supports the following accessors for BAM.Record types.","category":"page"},{"location":"man/bam/","page":"BAM","title":"BAM","text":"BAM.Record","category":"page"},{"location":"man/bam/#BAM.Reader-and-BAM.Writer","page":"BAM","title":"BAM.Reader and BAM.Writer","text":"","category":"section"},{"location":"man/bam/#Reference:","page":"BAM","title":"Reference:","text":"","category":"section"},{"location":"man/bam/","page":"BAM","title":"BAM","text":"BAM.Reader\nBAM.Writer","category":"page"},{"location":"man/files/#Readers-and-writers","page":"File I/O","title":"Readers and writers","text":"","category":"section"},{"location":"man/files/#Reading-SAM-and-BAM-files","page":"File I/O","title":"Reading SAM and BAM files","text":"","category":"section"},{"location":"man/files/","page":"File I/O","title":"File I/O","text":"Below is an example of a typical script iterating over all records in a file:","category":"page"},{"location":"man/files/","page":"File I/O","title":"File I/O","text":"using XAM\n\n# Open a BAM file.\nreader = open(BAM.Reader, \"data.bam\")\n\n# Iterate over BAM records.\nfor record in reader\n    # `record` is a BAM.Record object.\n    if BAM.ismapped(record)\n        # Print the mapped position.\n        println(BAM.refname(record), ':', BAM.position(record))\n    end\nend\n\n# Close the BAM file.\nclose(reader)","category":"page"},{"location":"man/files/","page":"File I/O","title":"File I/O","text":"The size of a BAM file is often extremely large. The iterator interface demonstrated above allocates an object for each record and that may be a bottleneck of reading data from a BAM file. In-place reading reuses a pre-allocated object for every record and less memory allocation happens in reading:","category":"page"},{"location":"man/files/","page":"File I/O","title":"File I/O","text":"reader = open(BAM.Reader, \"data.bam\")\nrecord = BAM.Record()\nwhile !eof(reader)\n    empty!(record)\n    read!(reader, record)\n    # do something\nend","category":"page"},{"location":"man/files/#Writing-SAM-and-BAM-files","page":"File I/O","title":"Writing SAM and BAM files","text":"","category":"section"},{"location":"man/files/","page":"File I/O","title":"File I/O","text":"In order to write a BAM or SAM file, you must first create a SAM.Header.","category":"page"},{"location":"man/files/","page":"File I/O","title":"File I/O","text":"A SAM.Header is constructed from a vector of SAM.MetaInfo objects.","category":"page"},{"location":"man/files/","page":"File I/O","title":"File I/O","text":"For example, to create the following simple header:","category":"page"},{"location":"man/files/","page":"File I/O","title":"File I/O","text":"@HD VN:1.6 SO:coordinate\n@SQ SN:ref LN:45","category":"page"},{"location":"man/files/","page":"File I/O","title":"File I/O","text":"julia> a = SAM.MetaInfo(\"HD\", [\"VN\" => 1.6, \"SO\" => \"coordinate\"])\nSAM.MetaInfo:\n    tag: HD\n  value: VN=1.6 SO=coordinate\n\njulia> b = SAM.MetaInfo(\"SQ\", [\"SN\" => \"ref\", \"LN\" => 45])\nSAM.MetaInfo:\n    tag: SQ\n  value: SN=ref LN=45\n\njulia> h = SAM.Header([a, b])\nSAM.Header(SAM.MetaInfo[SAM.MetaInfo:\n    tag: HD\n  value: VN=1.6 SO=coordinate, SAM.MetaInfo:\n    tag: SQ\n  value: SN=ref LN=45])\n","category":"page"},{"location":"man/files/","page":"File I/O","title":"File I/O","text":"Then to create the writer for a SAM file, construct a SAM.Writer using the header and an IO type:","category":"page"},{"location":"man/files/","page":"File I/O","title":"File I/O","text":"julia> samw = SAM.Writer(open(\"my-data.sam\", \"w\"), h)\nSAM.Writer(IOStream(<file my-data.sam>))\n","category":"page"},{"location":"man/files/","page":"File I/O","title":"File I/O","text":"To make a BAM Writer is slightly different, as you need to use a specific stream type from the https://github.com/BioJulia/BGZFStreams.jl package:","category":"page"},{"location":"man/files/","page":"File I/O","title":"File I/O","text":"julia> using BGZFStreams\n\njulia> bamw = BAM.Writer(BGZFStream(open(\"my-data.bam\", \"w\"), \"w\"))\nBAM.Writer(BGZFStreams.BGZFStream{IOStream}(<mode=write>))\n","category":"page"},{"location":"man/files/","page":"File I/O","title":"File I/O","text":"Once you have a BAM or SAM writer, you can use the write method to write BAM.Records or SAM.Records to file:","category":"page"},{"location":"man/files/","page":"File I/O","title":"File I/O","text":"julia> write(bamw, rec) # Here rec is a `BAM.Record`\n330780","category":"page"},{"location":"man/files/#Getting-records-overlapping-genomic-features","page":"File I/O","title":"Getting records overlapping genomic features","text":"","category":"section"},{"location":"man/files/","page":"File I/O","title":"File I/O","text":"The eachoverlap method also accepts the Interval type defined in GenomicFeatures.jl.","category":"page"},{"location":"man/files/","page":"File I/O","title":"File I/O","text":"This allows you to do things like first read in the genomic features from a GFF3 file, and then for each feature, iterate over all the BAM records that overlap with that feature.","category":"page"},{"location":"man/files/","page":"File I/O","title":"File I/O","text":"using GenomicFeatures\nusing GFF3\nusing XAM\n\n# Load genomic features from a GFF3 file.\nfeatures = open(collect, GFF3.Reader, \"TAIR10_GFF3_genes.gff\")\n\n# Keep mRNA features.\nfilter!(x -> GFF3.featuretype(x) == \"mRNA\", features)\n\n# Open a BAM file and iterate over records overlapping mRNA transcripts.\nreader = open(BAM.Reader, \"SRR1238088.sort.bam\")\nfor feature in features\n    for record in eachoverlap(reader, feature)\n        # `record` overlaps `feature`.\n        # ...\n    end\nend\nclose(reader)","category":"page"},{"location":"man/records/","page":"Records","title":"Records","text":"The XAM package offers high-performance tools for SAM and BAM file formats, which are the most popular file formats.","category":"page"},{"location":"man/records/","page":"Records","title":"Records","text":"If you have questions about the SAM and BAM formats or any of the terminology used when discussing these formats, see the published specification, which is maintained by the samtools group.","category":"page"},{"location":"man/records/","page":"Records","title":"Records","text":"A very very simple SAM file looks like the following:","category":"page"},{"location":"man/records/","page":"Records","title":"Records","text":"@HD VN:1.6 SO:coordinate\n@SQ SN:ref LN:45\nr001   99 ref  7 30 8M2I4M1D3M = 37  39 TTAGATAAAGGATACTG *\nr002    0 ref  9 30 3S6M1P1I4M *  0   0 AAAAGATAAGGATA    *\nr003    0 ref  9 30 5S6M       *  0   0 GCCTAAGCTAA       * SA:Z:ref,29,-,6H5M,17,0;\nr004    0 ref 16 30 6M14N5M    *  0   0 ATAGCTTCAGC       *\nr003 2064 ref 29 17 6H5M       *  0   0 TAGGC             * SA:Z:ref,9,+,5S6M,30,1;\nr001  147 ref 37 30 9M         =  7 -39 CAGCGGCAT         * NM:i:1","category":"page"},{"location":"man/records/","page":"Records","title":"Records","text":"Where the first two lines are part of the \"header\", and the following lines are \"records\". Each record describes how a read aligns to some reference sequence. Sometimes one record describes one read, but there are other cases like chimeric reads and split alignments, where multiple records apply to one read. In the example above, r003 is a chimeric read, and r004 is a split alignment, and r001 are mate pair reads. Again, we refer you to the official specification for more details.","category":"page"},{"location":"man/records/","page":"Records","title":"Records","text":"A BAM file stores this same information but in a binary and compressible format that does not make for pretty printing here!","category":"page"},{"location":"man/records/#SAM-and-BAM-Headers","page":"Records","title":"SAM and BAM Headers","text":"","category":"section"},{"location":"man/records/","page":"Records","title":"Records","text":"Both SAM.Reader and BAM.Reader implement the header function, which returns a SAM.Header object. To extract certain information out of the headers, you can use the find method on the header to extract information according to SAM/BAM tag. Again we refer you to the specification for full details of all the different tags that can occur in headers, and what they mean.","category":"page"},{"location":"man/records/","page":"Records","title":"Records","text":"Below is an example of extracting all the info about the reference sequences from the BAM header. In SAM/BAM, any description of a reference sequence is stored in the header, under a tag denoted SQ (think reference SeQuence!).","category":"page"},{"location":"man/records/","page":"Records","title":"Records","text":"julia> reader = open(SAM.Reader, \"data.sam\");\n\njulia> find(header(reader), \"SQ\")\n7-element Array{Bio.Align.SAM.MetaInfo,1}:\n Bio.Align.SAM.MetaInfo:\n    tag: SQ\n  value: SN=Chr1 LN=30427671\n Bio.Align.SAM.MetaInfo:\n    tag: SQ\n  value: SN=Chr2 LN=19698289\n Bio.Align.SAM.MetaInfo:\n    tag: SQ\n  value: SN=Chr3 LN=23459830\n Bio.Align.SAM.MetaInfo:\n    tag: SQ\n  value: SN=Chr4 LN=18585056\n Bio.Align.SAM.MetaInfo:\n    tag: SQ\n  value: SN=Chr5 LN=26975502\n Bio.Align.SAM.MetaInfo:\n    tag: SQ\n  value: SN=chloroplast LN=154478\n Bio.Align.SAM.MetaInfo:\n    tag: SQ\n  value: SN=mitochondria LN=366924\n","category":"page"},{"location":"man/records/","page":"Records","title":"Records","text":"In the above we can see there were 7 sequences in the reference: 5 chromosomes, one chloroplast sequence, and one mitochondrial sequence.","category":"page"},{"location":"man/records/#Accessing-auxiliary-data","page":"Records","title":"Accessing auxiliary data","text":"","category":"section"},{"location":"man/records/","page":"Records","title":"Records","text":"SAM and BAM records support the storing of optional data fields associated with tags.","category":"page"},{"location":"man/records/","page":"Records","title":"Records","text":"Tagged auxiliary data follows a format of TAG:TYPE:VALUE. TAG is a two-letter string, and each tag can only appear once per record. TYPE is a single case-sensetive letter which defined the format of VALUE.","category":"page"},{"location":"man/records/","page":"Records","title":"Records","text":"Type Description\n'A' Printable character\n'i' Signed integer\n'f' Single-precision floating number\n'Z' Printable string, including space\n'H' Byte array in Hex format\n'B' Integer of numeric array","category":"page"},{"location":"man/records/","page":"Records","title":"Records","text":"For more information about these tags and their types we refer you to the SAM/BAM specification and the additional optional fields specification document.","category":"page"},{"location":"man/records/","page":"Records","title":"Records","text":"There are some tags that are reserved, predefined standard tags, for specific uses.","category":"page"},{"location":"man/records/","page":"Records","title":"Records","text":"To access optional fields stored in tags, you use getindex indexing syntax on the record object. Note that accessing optional tag fields will result in type instability in Julia. This is because the type of the optional data is not known until run-time, as the tag is being read. This can have a significant impact on performance. To limit this, if the user knows the type of a value in advance, specifying it as a type annotation will alleviate the problem:","category":"page"},{"location":"man/records/","page":"Records","title":"Records","text":"Below is an example of looping over records in a bam file and using indexing syntax to get the data stored in the \"NM\" tag. Note the UInt8 type assertion to alleviate type instability.","category":"page"},{"location":"man/records/","page":"Records","title":"Records","text":"for record in open(BAM.Reader, \"data.bam\")\n    nm = record[\"NM\"]::UInt8\n    # do something\nend","category":"page"},{"location":"#XAM","page":"Overview","title":"XAM","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"(Image: Project Status: Active – The project has reached a stable, usable state and is being actively developed.) (Image: Latest Release) (Image: MIT license) (Image: Stable documentation) (Image: Latest documentation)","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"The XAM package provides I/O and utilities for manipulating SAM and BAM formatted alignment map files.","category":"page"},{"location":"#Installation","page":"Overview","title":"Installation","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"You can install the XAM package from the Julia REPL. Press ] to enter pkg mode, then enter the following command:","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"add XAM","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"If you are interested in the cutting edge of the development, please check out the develop branch to try new features before release.","category":"page"},{"location":"#Contributing","page":"Overview","title":"Contributing","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"We appreciate contributions from users including reporting bugs, fixing issues, improving performance and adding new features.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"Take a look at the contributing files detailed contributor and maintainer guidelines, and code of conduct.","category":"page"},{"location":"#Questions?","page":"Overview","title":"Questions?","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"If you have a question about contributing or using BioJulia software, come on over and chat to us on the Julia Slack workspace, or you can try the Bio category of the Julia discourse site.","category":"page"},{"location":"man/api/","page":"API Reference","title":"API Reference","text":"CurrentModule = XAM\nDocTestSetup = quote\n    using XAM\nend","category":"page"},{"location":"man/api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"man/api/#SAM-API","page":"API Reference","title":"SAM API","text":"","category":"section"},{"location":"man/api/#Public","page":"API Reference","title":"Public","text":"","category":"section"},{"location":"man/api/","page":"API Reference","title":"API Reference","text":"Modules = [XAM.SAM]\nprivate = false","category":"page"},{"location":"man/api/#XAM.SAM.Header-Tuple{}","page":"API Reference","title":"XAM.SAM.Header","text":"SAM.Header()\n\nCreate an empty header.\n\n\n\n\n\n","category":"method"},{"location":"man/api/#XAM.SAM.MetaInfo-Tuple{AbstractString, Any}","page":"API Reference","title":"XAM.SAM.MetaInfo","text":"MetaInfo(tag::AbstractString, value)\n\nCreate a SAM metainfo with tag and value.\n\ntag is a two-byte ASCII string. If tag is \"CO\", value must be a string; otherwise, value is an iterable object with key and value pairs.\n\nExamples\n\njulia> SAM.MetaInfo(\"CO\", \"some comment\")\nBioAlignments.SAM.MetaInfo:\n    tag: CO\n  value: some comment\n\njulia> string(ans)\n\"@CO\tsome comment\"\n\njulia> SAM.MetaInfo(\"SQ\", [\"SN\" => \"chr1\", \"LN\" => 12345])\nBioAlignments.SAM.MetaInfo:\n    tag: SQ\n  value: SN=chr1 LN=12345\n\njulia> string(ans)\n\"@SQ\tSN:chr1\tLN:12345\"\n\n\n\n\n\n","category":"method"},{"location":"man/api/#XAM.SAM.MetaInfo-Tuple{AbstractString}","page":"API Reference","title":"XAM.SAM.MetaInfo","text":"MetaInfo(str::AbstractString)\n\nCreate a SAM metainfo from str.\n\nExamples\n\njulia> SAM.MetaInfo(\"@CO\tsome comment\")\nBioAlignments.SAM.MetaInfo:\n    tag: CO\n  value: some comment\n\njulia> SAM.MetaInfo(\"@SQ\tSN:chr1\tLN:12345\")\nBioAlignments.SAM.MetaInfo:\n    tag: SQ\n  value: SN=chr1 LN=12345\n\n\n\n\n\n","category":"method"},{"location":"man/api/#XAM.SAM.Reader-Tuple{IO}","page":"API Reference","title":"XAM.SAM.Reader","text":"SAM.Reader(input::IO)\n\nCreate a data reader of the SAM file format.\n\nArguments\n\ninput: data source\n\n\n\n\n\n","category":"method"},{"location":"man/api/#XAM.SAM.Record-Tuple{AbstractString}","page":"API Reference","title":"XAM.SAM.Record","text":"SAM.Record(str::AbstractString)\n\nCreate a SAM record from str. This function verifies the format and indexes fields for accessors.\n\n\n\n\n\n","category":"method"},{"location":"man/api/#XAM.SAM.Record-Tuple{Vector{UInt8}}","page":"API Reference","title":"XAM.SAM.Record","text":"SAM.Record(data::Vector{UInt8})\n\nCreate a SAM record from data. This function verifies the format and indexes fields for accessors. Note that the ownership of data is transferred to a new record object.\n\n\n\n\n\n","category":"method"},{"location":"man/api/#XAM.SAM.Record-Tuple{}","page":"API Reference","title":"XAM.SAM.Record","text":"SAM.Record()\n\nCreate an unfilled SAM record.\n\n\n\n\n\n","category":"method"},{"location":"man/api/#XAM.SAM.Writer","page":"API Reference","title":"XAM.SAM.Writer","text":"Writer(output::IO, header::Header=Header())\n\nCreate a data writer of the SAM file format.\n\nArguments\n\noutput: data sink\nheader=Header(): SAM header object\n\n\n\n\n\n","category":"type"},{"location":"man/api/#Base.findall-Tuple{XAM.SAM.Header, AbstractString}","page":"API Reference","title":"Base.findall","text":"findall(header::Header, key::AbstractString)::Vector{MetaInfo}\n\nFind metainfo objects satisfying SAM.tag(metainfo) == key.\n\n\n\n\n\n","category":"method"},{"location":"man/api/#Base.read!-Tuple{XAM.SAM.Reader, XAM.SAM.Record}","page":"API Reference","title":"Base.read!","text":"read!(rdr::Reader, rec::Record)\n\nRead a Record into rec; overwriting or adding to existing field values. It is assumed that rec is already initialized or empty.\n\n\n\n\n\n","category":"method"},{"location":"man/api/#BioGenerics.header-Tuple{XAM.SAM.Reader}","page":"API Reference","title":"BioGenerics.header","text":"header(reader::Reader)::Header\n\nGet the header of reader.\n\n\n\n\n\n","category":"method"},{"location":"man/api/#XAM.SAM.alignlength-Tuple{XAM.SAM.Record}","page":"API Reference","title":"XAM.SAM.alignlength","text":"alignlength(record::Record)::Int\n\nGet the alignment length of record.\n\n\n\n\n\n","category":"method"},{"location":"man/api/#XAM.SAM.alignment-Tuple{XAM.SAM.Record}","page":"API Reference","title":"XAM.SAM.alignment","text":"alignment(record::Record)::BioAlignments.Alignment\n\nGet the alignment of record.\n\n\n\n\n\n","category":"method"},{"location":"man/api/#XAM.SAM.auxdata-Tuple{XAM.SAM.Record}","page":"API Reference","title":"XAM.SAM.auxdata","text":"auxdata(record::Record)::Dict{String,Any}\n\nGet the auxiliary data (optional fields) of record.\n\n\n\n\n\n","category":"method"},{"location":"man/api/#XAM.SAM.cigar-Tuple{XAM.SAM.Record}","page":"API Reference","title":"XAM.SAM.cigar","text":"cigar(record::Record)::String\n\nGet the CIGAR string of record.\n\n\n\n\n\n","category":"method"},{"location":"man/api/#XAM.SAM.iscomment-Tuple{XAM.SAM.MetaInfo}","page":"API Reference","title":"XAM.SAM.iscomment","text":"iscomment(metainfo::MetaInfo)::Bool\n\nTest if metainfo is a comment (i.e. its tag is \"CO\").\n\n\n\n\n\n","category":"method"},{"location":"man/api/#XAM.SAM.keyvalues-Tuple{XAM.SAM.MetaInfo}","page":"API Reference","title":"XAM.SAM.keyvalues","text":"keyvalues(metainfo::MetaInfo)::Vector{Pair{String,String}}\n\nGet the values of metainfo as string pairs.\n\n\n\n\n\n","category":"method"},{"location":"man/api/#XAM.SAM.mappingquality-Tuple{XAM.SAM.Record}","page":"API Reference","title":"XAM.SAM.mappingquality","text":"mappingquality(record::Record)::UInt8\n\nGet the mapping quality of record.\n\n\n\n\n\n","category":"method"},{"location":"man/api/#XAM.SAM.nextposition-Tuple{XAM.SAM.Record}","page":"API Reference","title":"XAM.SAM.nextposition","text":"nextposition(record::Record)::Int\n\nGet the position of the mate/next read of record.\n\n\n\n\n\n","category":"method"},{"location":"man/api/#XAM.SAM.nextrefname-Tuple{XAM.SAM.Record}","page":"API Reference","title":"XAM.SAM.nextrefname","text":"nextrefname(record::Record)::String\n\nGet the reference name of the mate/next read of record.\n\n\n\n\n\n","category":"method"},{"location":"man/api/#XAM.SAM.position-Tuple{XAM.SAM.Record}","page":"API Reference","title":"XAM.SAM.position","text":"position(record::Record)::Int\n\nGet the 1-based leftmost mapping position of record.\n\n\n\n\n\n","category":"method"},{"location":"man/api/#XAM.SAM.quality-Tuple{Type{String}, XAM.SAM.Record}","page":"API Reference","title":"XAM.SAM.quality","text":"quality(::Type{String}, record::Record)::String\n\nGet the ASCII-encoded base quality of record.\n\n\n\n\n\n","category":"method"},{"location":"man/api/#XAM.SAM.quality-Tuple{XAM.SAM.Record}","page":"API Reference","title":"XAM.SAM.quality","text":"quality(record::Record)::Vector{UInt8}\n\nGet the Phred-scaled base quality of record.\n\n\n\n\n\n","category":"method"},{"location":"man/api/#XAM.SAM.refname-Tuple{XAM.SAM.Record}","page":"API Reference","title":"XAM.SAM.refname","text":"refname(record::Record)::String\n\nGet the reference sequence name of record.\n\n\n\n\n\n","category":"method"},{"location":"man/api/#XAM.SAM.rightposition-Tuple{XAM.SAM.Record}","page":"API Reference","title":"XAM.SAM.rightposition","text":"rightposition(record::Record)::Int\n\nGet the 1-based rightmost mapping position of record.\n\n\n\n\n\n","category":"method"},{"location":"man/api/#XAM.SAM.seqlength-Tuple{XAM.SAM.Record}","page":"API Reference","title":"XAM.SAM.seqlength","text":"seqlength(record::Record)::Int\n\nGet the sequence length of record.\n\n\n\n\n\n","category":"method"},{"location":"man/api/#XAM.SAM.sequence-Tuple{Type{String}, XAM.SAM.Record}","page":"API Reference","title":"XAM.SAM.sequence","text":"sequence(::Type{String}, record::Record)::String\n\nGet the segment sequence of record as String.\n\n\n\n\n\n","category":"method"},{"location":"man/api/#XAM.SAM.sequence-Tuple{XAM.SAM.Record}","page":"API Reference","title":"XAM.SAM.sequence","text":"sequence(record::Record)::BioSequences.LongDNA{4}\n\nGet the segment sequence of record.\n\n\n\n\n\n","category":"method"},{"location":"man/api/#XAM.SAM.tag-Tuple{XAM.SAM.MetaInfo}","page":"API Reference","title":"XAM.SAM.tag","text":"tag(metainfo::MetaInfo)::String\n\nGet the tag of metainfo.\n\n\n\n\n\n","category":"method"},{"location":"man/api/#XAM.SAM.templength-Tuple{XAM.SAM.Record}","page":"API Reference","title":"XAM.SAM.templength","text":"templength(record::Record)::Int\n\nGet the template length of record.\n\n\n\n\n\n","category":"method"},{"location":"man/api/#XAM.SAM.tempname-Tuple{XAM.SAM.Record}","page":"API Reference","title":"XAM.SAM.tempname","text":"tempname(record::Record)::String\n\nGet the query template name of record.\n\n\n\n\n\n","category":"method"},{"location":"man/api/#XAM.SAM.value-Tuple{XAM.SAM.MetaInfo}","page":"API Reference","title":"XAM.SAM.value","text":"value(metainfo::MetaInfo)::String\n\nGet the value of metainfo as a string.\n\n\n\n\n\n","category":"method"},{"location":"man/api/#Internal","page":"API Reference","title":"Internal","text":"","category":"section"},{"location":"man/api/","page":"API Reference","title":"API Reference","text":"Modules = [XAM.SAM]\npublic = false","category":"page"},{"location":"man/api/#BAM-API","page":"API Reference","title":"BAM API","text":"","category":"section"},{"location":"man/api/#Public-2","page":"API Reference","title":"Public","text":"","category":"section"},{"location":"man/api/","page":"API Reference","title":"API Reference","text":"Modules = [XAM.BAM]\nprivate = false","category":"page"},{"location":"man/api/#XAM.BAM.BAI-Tuple{AbstractString}","page":"API Reference","title":"XAM.BAM.BAI","text":"BAI(filename::AbstractString)\n\nLoad a BAI index from filename.\n\n\n\n\n\n","category":"method"},{"location":"man/api/#XAM.BAM.BAI-Tuple{IO}","page":"API Reference","title":"XAM.BAM.BAI","text":"BAI(input::IO)\n\nLoad a BAI index from input.\n\n\n\n\n\n","category":"method"},{"location":"man/api/#XAM.BAM.Reader","page":"API Reference","title":"XAM.BAM.Reader","text":"BAM.Reader(input::IO; index=nothing)\n\nCreate a data reader of the BAM file format.\n\nArguments\n\ninput: data source\nindex=nothing: filepath to a random access index (currently bai is supported) or BAI object\n\n\n\n\n\n","category":"type"},{"location":"man/api/#XAM.BAM.Record","page":"API Reference","title":"XAM.BAM.Record","text":"BAM.Record()\n\nCreate an unfilled BAM record.\n\n\n\n\n\n","category":"type"},{"location":"man/api/#XAM.BAM.Writer","page":"API Reference","title":"XAM.BAM.Writer","text":"BAM.Writer(output::BGZFStream, header::SAM.Header)\n\nCreate a data writer of the BAM file format.\n\nArguments\n\noutput: data sink\nheader: SAM header object\n\n\n\n\n\n","category":"type"},{"location":"man/api/#BioGenerics.header-Tuple{XAM.BAM.Reader}","page":"API Reference","title":"BioGenerics.header","text":"header(reader::Reader; fillSQ::Bool=false)::SAM.Header\n\nGet the header of reader.\n\nIf fillSQ is true, this function fills missing \"SQ\" metainfo in the header.\n\n\n\n\n\n","category":"method"},{"location":"man/api/#XAM.BAM.alignlength-Tuple{XAM.BAM.Record}","page":"API Reference","title":"XAM.BAM.alignlength","text":"alignlength(record::Record)::Int\n\nGet the alignment length of record.\n\n\n\n\n\n","category":"method"},{"location":"man/api/#XAM.BAM.alignment-Tuple{XAM.BAM.Record}","page":"API Reference","title":"XAM.BAM.alignment","text":"alignment(record::Record)::BioAlignments.Alignment\n\nGet the alignment of record.\n\n\n\n\n\n","category":"method"},{"location":"man/api/#XAM.BAM.auxdata-Tuple{XAM.BAM.Record}","page":"API Reference","title":"XAM.BAM.auxdata","text":"auxdata(record::Record)::BAM.AuxData\n\nGet the auxiliary data of record.\n\n\n\n\n\n","category":"method"},{"location":"man/api/#XAM.BAM.cigar","page":"API Reference","title":"XAM.BAM.cigar","text":"cigar(record::Record)::String\n\nGet the CIGAR string of record.\n\nNote that in the BAM specification, the field called cigar typically stores the cigar string of the record. However, this is not always true, sometimes the true cigar is very long, and due to  some constraints of the BAM format, the actual cigar string is stored in an extra tag: CG:B,I, and the cigar field stores a pseudo-cigar string.\n\nCalling this method with checkCG set to true (default) this method will always yield the true cigar string, because this is probably what you want the vast majority of the time.\n\nIf you have a record that stores the true cigar in a CG:B,I tag, but you still want to access the pseudo-cigar that is stored in the cigar field of the BAM record, then you can set checkCG to false.\n\nSee also BAM.cigar_rle.\n\n\n\n\n\n","category":"function"},{"location":"man/api/#XAM.BAM.cigar_rle","page":"API Reference","title":"XAM.BAM.cigar_rle","text":"cigar_rle(record::Record, checkCG::Bool = true)::Tuple{Vector{BioAlignments.Operation},Vector{Int}}\n\nGet a run-length encoded tuple (ops, lens) of the CIGAR string in record.\n\nNote that in the BAM specification, the field called cigar typically stores the cigar string of the record. However, this is not always true, sometimes the true cigar is very long, and due to  some constraints of the BAM format, the actual cigar string is stored in an extra tag: CG:B,I, and the cigar field stores a pseudo-cigar string.\n\nCalling this method with checkCG set to true (default) this method will always yield the true cigar string, because this is probably what you want the vast majority of the time.\n\nIf you have a record that stores the true cigar in a CG:B,I tag, but you still want to access the pseudo-cigar that is stored in the cigar field of the BAM record, then you can set checkCG to false.\n\nSee also BAM.cigar.\n\n\n\n\n\n","category":"function"},{"location":"man/api/#XAM.BAM.mappingquality-Tuple{XAM.BAM.Record}","page":"API Reference","title":"XAM.BAM.mappingquality","text":"mappingquality(record::Record)::UInt8\n\nGet the mapping quality of record.\n\n\n\n\n\n","category":"method"},{"location":"man/api/#XAM.BAM.n_cigar_op","page":"API Reference","title":"XAM.BAM.n_cigar_op","text":"n_cigar_op(record::Record, checkCG::Bool = true)\n\nReturn the number of operations in the CIGAR string of record.\n\nNote that in the BAM specification, the field called cigar typically stores the cigar string of the record. However, this is not always true, sometimes the true cigar is very long, and due to  some constraints of the BAM format, the actual cigar string is stored in an extra tag: CG:B,I, and the cigar field stores a pseudo-cigar string.\n\nCalling this method with checkCG set to true (default) this method will always yield the number of operations in the true cigar string, because this is probably what you want, the vast majority of the time.\n\nIf you have a record that stores the true cigar in a CG:B,I tag, but you still want to get the number of operations in the cigar field of the BAM record, then set checkCG to false.\n\n\n\n\n\n","category":"function"},{"location":"man/api/#XAM.BAM.nextposition-Tuple{XAM.BAM.Record}","page":"API Reference","title":"XAM.BAM.nextposition","text":"nextposition(record::Record)::Int\n\nGet the 1-based leftmost mapping position of the next/mate read of record.\n\n\n\n\n\n","category":"method"},{"location":"man/api/#XAM.BAM.nextrefid-Tuple{XAM.BAM.Record}","page":"API Reference","title":"XAM.BAM.nextrefid","text":"nextrefid(record::Record)::Int\n\nGet the next/mate reference sequence ID of record.\n\n\n\n\n\n","category":"method"},{"location":"man/api/#XAM.BAM.nextrefname-Tuple{XAM.BAM.Record}","page":"API Reference","title":"XAM.BAM.nextrefname","text":"nextrefname(record::Record)::String\n\nGet the reference name of the mate/next read of record.\n\n\n\n\n\n","category":"method"},{"location":"man/api/#XAM.BAM.position-Tuple{XAM.BAM.Record}","page":"API Reference","title":"XAM.BAM.position","text":"position(record::Record)::Int\n\nGet the 1-based leftmost mapping position of record.\n\n\n\n\n\n","category":"method"},{"location":"man/api/#XAM.BAM.quality-Tuple{XAM.BAM.Record}","page":"API Reference","title":"XAM.BAM.quality","text":"quality(record::Record)\n\nGet the base quality of record.\n\n\n\n\n\n","category":"method"},{"location":"man/api/#XAM.BAM.refid-Tuple{XAM.BAM.Record}","page":"API Reference","title":"XAM.BAM.refid","text":"refid(record::Record)::Int\n\nGet the reference sequence ID of record.\n\nThe ID is 1-based (i.e. the first sequence is 1) and is 0 for a record without a mapping position.\n\nSee also: BAM.rname\n\n\n\n\n\n","category":"method"},{"location":"man/api/#XAM.BAM.reflen-Tuple{XAM.BAM.Record}","page":"API Reference","title":"XAM.BAM.reflen","text":"reflen(record::Record)::Int\n\nGet the length of the reference sequence this record applies to.\n\n\n\n\n\n","category":"method"},{"location":"man/api/#XAM.BAM.refname-Tuple{XAM.BAM.Record}","page":"API Reference","title":"XAM.BAM.refname","text":"refname(record::Record)::String\n\nGet the reference sequence name of record.\n\nSee also: BAM.refid\n\n\n\n\n\n","category":"method"},{"location":"man/api/#XAM.BAM.rightposition-Tuple{XAM.BAM.Record}","page":"API Reference","title":"XAM.BAM.rightposition","text":"rightposition(record::Record)::Int\n\nGet the 1-based rightmost mapping position of record.\n\n\n\n\n\n","category":"method"},{"location":"man/api/#XAM.BAM.seqlength-Tuple{XAM.BAM.Record}","page":"API Reference","title":"XAM.BAM.seqlength","text":"seqlength(record::Record)::Int\n\nGet the sequence length of record.\n\n\n\n\n\n","category":"method"},{"location":"man/api/#XAM.BAM.sequence-Tuple{XAM.BAM.Record}","page":"API Reference","title":"XAM.BAM.sequence","text":"sequence(record::Record)::BioSequences.LongDNA{4}\n\nGet the segment sequence of record.\n\n\n\n\n\n","category":"method"},{"location":"man/api/#XAM.BAM.templength-Tuple{XAM.BAM.Record}","page":"API Reference","title":"XAM.BAM.templength","text":"templength(record::Record)::Int\n\nGet the template length of record.\n\n\n\n\n\n","category":"method"},{"location":"man/api/#XAM.BAM.tempname-Tuple{XAM.BAM.Record}","page":"API Reference","title":"XAM.BAM.tempname","text":"tempname(record::Record)::String\n\nGet the query template name of record.\n\n\n\n\n\n","category":"method"},{"location":"man/api/#Internal-2","page":"API Reference","title":"Internal","text":"","category":"section"},{"location":"man/api/","page":"API Reference","title":"API Reference","text":"Modules = [XAM.BAM]\npublic = false","category":"page"},{"location":"man/bai/#BAI-files","page":"BAI files","title":"BAI files","text":"","category":"section"},{"location":"man/bai/","page":"BAI files","title":"BAI files","text":"The XAM package supports the BAI index to fetch records in a specific range from a BAM file. Samtools provides index subcommand to create an index file (.bai) from a sorted BAM file.","category":"page"},{"location":"man/bai/","page":"BAI files","title":"BAI files","text":"$ samtools index -b SRR1238088.sort.bam\n$ ls SRR1238088.sort.bam*\nSRR1238088.sort.bam     SRR1238088.sort.bam.bai","category":"page"},{"location":"man/bai/","page":"BAI files","title":"BAI files","text":"The method eachoverlap(reader, chrom, range) returns an iterator of BAM records overlapping the query interval:","category":"page"},{"location":"man/bai/","page":"BAI files","title":"BAI files","text":"reader = open(BAM.Reader, \"SRR1238088.sort.bam\", index=\"SRR1238088.sort.bam.bai\")\nfor record in eachoverlap(reader, \"Chr2\", 10000:11000)\n    # `record` is a BAM.Record object\n    # ...\nend\nclose(reader)","category":"page"}]
}
